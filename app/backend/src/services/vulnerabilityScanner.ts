/**
 * Vulnerability Scanner Service
 * 
 * Automated security vulnerability scanning and assessment for the Web3 marketplace,
 * including dependency scanning, code analysis, and smart contract security checks.
 */

import { execSync } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';
import { securityConfig } from '../config/securityConfig';
import AuditLoggingService from './auditLoggingService';

const auditLoggingService = new AuditLoggingService();
import { securityMonitoringService, SecurityEventType, SecuritySeverity } from './securityMonitoringService';

export interface VulnerabilityReport {
  id: string;
  scanType: ScanType;
  timestamp: Date;
  status: ScanStatus;
  summary: {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    fixedCount: number;
  };
  vulnerabilities: Vulnerability[];
  recommendations: string[];
  nextScanDate: Date;
}

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  cvssScore: number;
  cveId?: string;
  category: VulnerabilityCategory;
  affectedComponent: string;
  affectedVersion?: string;
  fixedVersion?: string;
  exploitability: ExploitabilityLevel;
  impact: ImpactLevel;
  discoveredAt: Date;
  fixedAt?: Date;
  status: VulnerabilityStatus;
  remediation: RemediationInfo;
  references: string[];
}

export enum ScanType {
  DEPENDENCY_SCAN = 'dependency_scan',
  CODE_ANALYSIS = 'code_analysis',
  SMART_CONTRACT_AUDIT = 'smart_contract_audit',
  INFRASTRUCTURE_SCAN = 'infrastructure_scan',
  WEB_APPLICATION_SCAN = 'web_application_scan',
  COMPREHENSIVE_SCAN = 'comprehensive_scan',
}

export enum ScanStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled',
}

export enum VulnerabilitySeverity {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
  INFO = 'info',
}

export enum VulnerabilityCategory {
  INJECTION = 'injection',
  AUTHENTICATION = 'authentication',
  AUTHORIZATION = 'authorization',
  CRYPTOGRAPHY = 'cryptography',
  CONFIGURATION = 'configuration',
  DEPENDENCY = 'dependency',
  SMART_CONTRACT = 'smart_contract',
  BUSINESS_LOGIC = 'business_logic',
  DATA_EXPOSURE = 'data_exposure',
  DENIAL_OF_SERVICE = 'denial_of_service',
}

export enum ExploitabilityLevel {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
}

export enum ImpactLevel {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
}

export enum VulnerabilityStatus {
  OPEN = 'open',
  ACKNOWLEDGED = 'acknowledged',
  IN_PROGRESS = 'in_progress',
  FIXED = 'fixed',
  WONT_FIX = 'wont_fix',
  FALSE_POSITIVE = 'false_positive',
}

export interface RemediationInfo {
  description: string;
  steps: string[];
  estimatedEffort: string;
  priority: 'immediate' | 'high' | 'medium' | 'low';
  automatable: boolean;
  references: string[];
}

class VulnerabilityScanner {
  private scanHistory: Map<string, VulnerabilityReport> = new Map();
  private activeScan: string | null = null;

  constructor() {
    this.initializeScanner();
  }

  /**
   * Initialize vulnerability scanner
   */
  private initializeScanner(): void {
    // Schedule periodic scans
    if (securityConfig.vulnerability.scanningEnabled) {
      setInterval(() => {
        this.performScheduledScan();
      }, securityConfig.vulnerability.scanInterval);
    }

    console.log('Vulnerability scanner initialized');
  }

  /**
   * Perform comprehensive security scan
   */
  async performComprehensiveScan(): Promise<VulnerabilityReport> {
    const scanId = crypto.randomUUID();
    
    const report: VulnerabilityReport = {
      id: scanId,
      scanType: ScanType.COMPREHENSIVE_SCAN,
      timestamp: new Date(),
      status: ScanStatus.RUNNING,
      summary: {
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        fixedCount: 0,
      },
      vulnerabilities: [],
      recommendations: [],
      nextScanDate: new Date(Date.now() + securityConfig.vulnerability.scanInterval),
    };

    this.activeScan = scanId;
    this.scanHistory.set(scanId, report);

    try {
      // Log scan start
      await auditLoggingService.createAuditLog({
        actionType: 'vulnerability_scan_started',
        actorType: 'system',
        newState: { scanId, scanType: report.scanType },
      });

      // Perform different types of scans
      const dependencyVulns = await this.scanDependencies();
      const codeVulns = await this.performCodeAnalysis();
      const contractVulns = await this.scanSmartContracts();
      const infraVulns = await this.scanInfrastructure();
      const webVulns = await this.scanWebApplication();

      // Combine all vulnerabilities
      report.vulnerabilities = [
        ...dependencyVulns,
        ...codeVulns,
        ...contractVulns,
        ...infraVulns,
        ...webVulns,
      ];

      // Update summary
      this.updateReportSummary(report);

      // Generate recommendations
      report.recommendations = this.generateRecommendations(report.vulnerabilities);

      report.status = ScanStatus.COMPLETED;

      // Process critical vulnerabilities
      await this.processCriticalVulnerabilities(report.vulnerabilities);

      // Log scan completion
      await auditLoggingService.createAuditLog({
        actionType: 'vulnerability_scan_completed',
        actorType: 'system',
        newState: {
          scanId,
          totalVulnerabilities: report.summary.totalVulnerabilities,
          criticalCount: report.summary.criticalCount,
        },
      });

    } catch (error) {
      report.status = ScanStatus.FAILED;
      console.error('Vulnerability scan failed:', error);
      
      await auditLoggingService.createAuditLog({
        actionType: 'vulnerability_scan_failed',
        actorType: 'system',
        newState: { scanId, error: error instanceof Error ? error.message : 'Unknown error' },
      });
    } finally {
      this.activeScan = null;
    }

    return report;
  }

  /**
   * Scan dependencies for known vulnerabilities
   */
  private async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Scan Node.js dependencies using npm audit
      const npmAuditResult = await this.runNpmAudit();
      vulnerabilities.push(...this.parseNpmAuditResults(npmAuditResult));

      // Scan Python dependencies if present
      const pythonVulns = await this.scanPythonDependencies();
      vulnerabilities.push(...pythonVulns);

      // Scan Solidity dependencies
      const solidityVulns = await this.scanSolidityDependencies();
      vulnerabilities.push(...solidityVulns);

    } catch (error) {
      console.error('Dependency scan failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Perform static code analysis
   */
  private async performCodeAnalysis(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Analyze TypeScript/JavaScript code
      const jsVulns = await this.analyzeJavaScriptCode();
      vulnerabilities.push(...jsVulns);

      // Analyze Solidity code
      const solidityVulns = await this.analyzeSolidityCode();
      vulnerabilities.push(...solidityVulns);

      // Check for common security patterns
      const patternVulns = await this.checkSecurityPatterns();
      vulnerabilities.push(...patternVulns);

    } catch (error) {
      console.error('Code analysis failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Scan smart contracts for vulnerabilities
   */
  private async scanSmartContracts(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Use Slither for static analysis
      const slitherResults = await this.runSlitherAnalysis();
      vulnerabilities.push(...this.parseSlitherResults(slitherResults));

      // Use MythX for comprehensive analysis
      const mythxResults = await this.runMythXAnalysis();
      vulnerabilities.push(...this.parseMythXResults(mythxResults));

      // Custom smart contract checks
      const customChecks = await this.performCustomContractChecks();
      vulnerabilities.push(...customChecks);

    } catch (error) {
      console.error('Smart contract scan failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Scan infrastructure for vulnerabilities
   */
  private async scanInfrastructure(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Scan Docker images
      const dockerVulns = await this.scanDockerImages();
      vulnerabilities.push(...dockerVulns);

      // Scan Kubernetes configurations
      const k8sVulns = await this.scanKubernetesConfigs();
      vulnerabilities.push(...k8sVulns);

      // Check server configurations
      const configVulns = await this.checkServerConfigurations();
      vulnerabilities.push(...configVulns);

    } catch (error) {
      console.error('Infrastructure scan failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Scan web application for vulnerabilities
   */
  private async scanWebApplication(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // OWASP ZAP scan
      const zapResults = await this.runZAPScan();
      vulnerabilities.push(...this.parseZAPResults(zapResults));

      // Custom web application checks
      const customWebChecks = await this.performCustomWebChecks();
      vulnerabilities.push(...customWebChecks);

    } catch (error) {
      console.error('Web application scan failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Run npm audit
   */
  private async runNpmAudit(): Promise<any> {
    try {
      const result = execSync('npm audit --json', { 
        cwd: process.cwd(),
        encoding: 'utf8',
        timeout: 60000,
      });
      return JSON.parse(result);
    } catch (error: any) {
      // npm audit returns non-zero exit code when vulnerabilities are found
      if (error.stdout) {
        return JSON.parse(error.stdout);
      }
      throw error;
    }
  }

  /**
   * Parse npm audit results
   */
  private parseNpmAuditResults(auditResult: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (auditResult.vulnerabilities) {
      for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities as any)) {
        const vuln = vulnData as any;
        
        vulnerabilities.push({
          id: crypto.randomUUID(),
          title: `${packageName}: ${vuln.title || 'Dependency vulnerability'}`,
          description: vuln.overview || 'No description available',
          severity: this.mapNpmSeverity(vuln.severity),
          cvssScore: vuln.cvss?.score || 0,
          cveId: vuln.cves?.[0],
          category: VulnerabilityCategory.DEPENDENCY,
          affectedComponent: packageName,
          affectedVersion: vuln.range,
          fixedVersion: vuln.fixAvailable ? 'Available' : undefined,
          exploitability: this.mapExploitability(vuln.severity),
          impact: this.mapImpact(vuln.severity),
          discoveredAt: new Date(),
          status: VulnerabilityStatus.OPEN,
          remediation: {
            description: `Update ${packageName} to a secure version`,
            steps: [
              `Run: npm update ${packageName}`,
              'Test application functionality',
              'Deploy updated dependencies',
            ],
            estimatedEffort: '1-2 hours',
            priority: vuln.severity === 'critical' ? 'immediate' : 'high',
            automatable: true,
            references: vuln.references || [],
          },
          references: vuln.references || [],
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Scan Python dependencies
   */
  private async scanPythonDependencies(): Promise<Vulnerability[]> {
    // Implementation would use safety or similar tool
    return [];
  }

  /**
   * Scan Solidity dependencies
   */
  private async scanSolidityDependencies(): Promise<Vulnerability[]> {
    // Implementation would check OpenZeppelin and other Solidity dependencies
    return [];
  }

  /**
   * Analyze JavaScript/TypeScript code
   */
  private async analyzeJavaScriptCode(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Use ESLint security plugin
      const eslintResults = await this.runESLintSecurity();
      vulnerabilities.push(...this.parseESLintResults(eslintResults));

      // Use Semgrep for security analysis
      const semgrepResults = await this.runSemgrep();
      vulnerabilities.push(...this.parseSemgrepResults(semgrepResults));

    } catch (error) {
      console.error('JavaScript code analysis failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Analyze Solidity code
   */
  private async analyzeSolidityCode(): Promise<Vulnerability[]> {
    // Implementation would use Solhint and other Solidity analyzers
    return [];
  }

  /**
   * Check for common security patterns
   */
  private async checkSecurityPatterns(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for hardcoded secrets
    const secretsVulns = await this.checkForHardcodedSecrets();
    vulnerabilities.push(...secretsVulns);

    // Check for insecure configurations
    const configVulns = await this.checkInsecureConfigurations();
    vulnerabilities.push(...configVulns);

    return vulnerabilities;
  }

  /**
   * Check for hardcoded secrets
   */
  private async checkForHardcodedSecrets(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    const secretPatterns = [
      /(password|pwd|pass)\s*[:=]\s*['"][^'"]+['"]/gi,
      /(api[-_]?key|apikey)\s*[:=]\s*['"][^'"]+['"]/gi,
      /(secret|token)\s*[:=]\s*['"][^'"]+['"]/gi,
      /(private[-_]?key|privatekey)\s*[:=]\s*['"][^'"]+['"]/gi,
    ];

    try {
      const files = await this.getSourceFiles();
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf8');
        
        for (const pattern of secretPatterns) {
          const matches = content.match(pattern);
          if (matches) {
            vulnerabilities.push({
              id: crypto.randomUUID(),
              title: 'Hardcoded Secret Detected',
              description: `Potential hardcoded secret found in ${file}`,
              severity: VulnerabilitySeverity.HIGH,
              cvssScore: 7.5,
              category: VulnerabilityCategory.CRYPTOGRAPHY,
              affectedComponent: file,
              exploitability: ExploitabilityLevel.HIGH,
              impact: ImpactLevel.HIGH,
              discoveredAt: new Date(),
              status: VulnerabilityStatus.OPEN,
              remediation: {
                description: 'Remove hardcoded secrets and use environment variables',
                steps: [
                  'Move secret to environment variable',
                  'Update code to read from environment',
                  'Add to .env.example with placeholder',
                  'Update deployment configuration',
                ],
                estimatedEffort: '30 minutes',
                priority: 'high',
                automatable: false,
                references: [
                  'https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password',
                ],
              },
              references: [],
            });
          }
        }
      }
    } catch (error) {
      console.error('Failed to check for hardcoded secrets:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check for insecure configurations
   */
  private async checkInsecureConfigurations(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for insecure CORS configuration
    // Check for missing security headers
    // Check for weak encryption settings
    // etc.

    return vulnerabilities;
  }

  /**
   * Process critical vulnerabilities
   */
  private async processCriticalVulnerabilities(vulnerabilities: Vulnerability[]): Promise<void> {
    const criticalVulns = vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.CRITICAL);

    for (const vuln of criticalVulns) {
      // Create security event
      await securityMonitoringService.recordSecurityEvent({
        type: SecurityEventType.VULNERABILITY_EXPLOIT,
        severity: SecuritySeverity.CRITICAL,
        source: 'vulnerability_scanner',
        details: {
          vulnerabilityId: vuln.id,
          title: vuln.title,
          cvssScore: vuln.cvssScore,
          affectedComponent: vuln.affectedComponent,
        },
      });

      // Auto-remediate if possible
      if (securityConfig.vulnerability.autoRemediation && vuln.remediation.automatable) {
        await this.attemptAutoRemediation(vuln);
      }
    }
  }

  /**
   * Attempt automatic remediation
   */
  private async attemptAutoRemediation(vulnerability: Vulnerability): Promise<void> {
    try {
      if (vulnerability.category === VulnerabilityCategory.DEPENDENCY) {
        // Attempt to update vulnerable dependency
        await this.updateVulnerableDependency(vulnerability);
      }

      vulnerability.status = VulnerabilityStatus.IN_PROGRESS;
      
      await auditLoggingService.createAuditLog({
        actionType: 'vulnerability_auto_remediation_attempted',
        actorType: 'system',
        newState: {
          vulnerabilityId: vulnerability.id,
          component: vulnerability.affectedComponent,
        },
      });

    } catch (error) {
      console.error('Auto-remediation failed:', error);
    }
  }

  /**
   * Update vulnerable dependency
   */
  private async updateVulnerableDependency(vulnerability: Vulnerability): Promise<void> {
    // Implementation would attempt to update the vulnerable dependency
    console.log(`Attempting to update vulnerable dependency: ${vulnerability.affectedComponent}`);
  }

  /**
   * Perform scheduled scan
   */
  private async performScheduledScan(): Promise<void> {
    if (this.activeScan) {
      console.log('Scan already in progress, skipping scheduled scan');
      return;
    }

    console.log('Starting scheduled vulnerability scan');
    await this.performComprehensiveScan();
  }

  /**
   * Get scan history
   */
  public getScanHistory(): VulnerabilityReport[] {
    return Array.from(this.scanHistory.values())
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
  }

  /**
   * Get latest scan report
   */
  public getLatestScanReport(): VulnerabilityReport | null {
    const reports = this.getScanHistory();
    return reports.length > 0 ? reports[0] : null;
  }

  /**
   * Get vulnerability by ID
   */
  public getVulnerability(vulnerabilityId: string): Vulnerability | null {
    for (const report of this.scanHistory.values()) {
      const vuln = report.vulnerabilities.find(v => v.id === vulnerabilityId);
      if (vuln) return vuln;
    }
    return null;
  }

  /**
   * Update vulnerability status
   */
  public async updateVulnerabilityStatus(
    vulnerabilityId: string, 
    status: VulnerabilityStatus,
    userId: string
  ): Promise<void> {
    const vulnerability = this.getVulnerability(vulnerabilityId);
    if (vulnerability) {
      vulnerability.status = status;
      if (status === VulnerabilityStatus.FIXED) {
        vulnerability.fixedAt = new Date();
      }

      await auditLoggingService.createAuditLog({
        actionType: 'vulnerability_status_updated',
        actorId: userId,
        actorType: 'user',
        newState: {
          vulnerabilityId,
          newStatus: status,
          fixedAt: vulnerability.fixedAt,
        },
      });
    }
  }

  // Helper methods
  private updateReportSummary(report: VulnerabilityReport): void {
    report.summary.totalVulnerabilities = report.vulnerabilities.length;
    report.summary.criticalCount = report.vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.CRITICAL).length;
    report.summary.highCount = report.vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.HIGH).length;
    report.summary.mediumCount = report.vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.MEDIUM).length;
    report.summary.lowCount = report.vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.LOW).length;
    report.summary.fixedCount = report.vulnerabilities.filter(v => v.status === VulnerabilityStatus.FIXED).length;
  }

  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];

    const criticalCount = vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.CRITICAL).length;
    const highCount = vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.HIGH).length;

    if (criticalCount > 0) {
      recommendations.push(`Address ${criticalCount} critical vulnerabilities immediately`);
    }

    if (highCount > 0) {
      recommendations.push(`Plan remediation for ${highCount} high-severity vulnerabilities`);
    }

    const dependencyVulns = vulnerabilities.filter(v => v.category === VulnerabilityCategory.DEPENDENCY);
    if (dependencyVulns.length > 0) {
      recommendations.push('Update vulnerable dependencies to latest secure versions');
    }

    const contractVulns = vulnerabilities.filter(v => v.category === VulnerabilityCategory.SMART_CONTRACT);
    if (contractVulns.length > 0) {
      recommendations.push('Review and audit smart contract security issues');
    }

    return recommendations;
  }

  private mapNpmSeverity(severity: string): VulnerabilitySeverity {
    switch (severity?.toLowerCase()) {
      case 'critical': return VulnerabilitySeverity.CRITICAL;
      case 'high': return VulnerabilitySeverity.HIGH;
      case 'moderate': return VulnerabilitySeverity.MEDIUM;
      case 'low': return VulnerabilitySeverity.LOW;
      default: return VulnerabilitySeverity.MEDIUM;
    }
  }

  private mapExploitability(severity: string): ExploitabilityLevel {
    switch (severity?.toLowerCase()) {
      case 'critical': return ExploitabilityLevel.CRITICAL;
      case 'high': return ExploitabilityLevel.HIGH;
      case 'moderate': return ExploitabilityLevel.MEDIUM;
      case 'low': return ExploitabilityLevel.LOW;
      default: return ExploitabilityLevel.MEDIUM;
    }
  }

  private mapImpact(severity: string): ImpactLevel {
    switch (severity?.toLowerCase()) {
      case 'critical': return ImpactLevel.CRITICAL;
      case 'high': return ImpactLevel.HIGH;
      case 'moderate': return ImpactLevel.MEDIUM;
      case 'low': return ImpactLevel.LOW;
      default: return ImpactLevel.MEDIUM;
    }
  }

  private async getSourceFiles(): Promise<string[]> {
    // Implementation would recursively find source files
    return [];
  }

  // Placeholder methods for external tools
  private async runSlitherAnalysis(): Promise<any> { return {}; }
  private async runMythXAnalysis(): Promise<any> { return {}; }
  private async runZAPScan(): Promise<any> { return {}; }
  private async runESLintSecurity(): Promise<any> { return {}; }
  private async runSemgrep(): Promise<any> { return {}; }
  private async scanDockerImages(): Promise<Vulnerability[]> { return []; }
  private async scanKubernetesConfigs(): Promise<Vulnerability[]> { return []; }
  private async checkServerConfigurations(): Promise<Vulnerability[]> { return []; }
  private async performCustomContractChecks(): Promise<Vulnerability[]> { return []; }
  private async performCustomWebChecks(): Promise<Vulnerability[]> { return []; }
  
  private parseSlitherResults(results: any): Vulnerability[] { return []; }
  private parseMythXResults(results: any): Vulnerability[] { return []; }
  private parseZAPResults(results: any): Vulnerability[] { return []; }
  private parseESLintResults(results: any): Vulnerability[] { return []; }
  private parseSemgrepResults(results: any): Vulnerability[] { return []; }
}

export const vulnerabilityScanner = new VulnerabilityScanner();
export default vulnerabilityScanner;