/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export interface LDAOTreasuryInterface extends utils.Interface {
  functions: {
    "MULTI_SIG_THRESHOLD()": FunctionFragment;
    "addPricingTier(uint256,uint256)": FunctionFragment;
    "basePriceInUSD()": FunctionFragment;
    "batchUpdateKYC(address[],bool)": FunctionFragment;
    "currentDayPurchases()": FunctionFragment;
    "dailyPurchaseLimit()": FunctionFragment;
    "dailyPurchases(address)": FunctionFragment;
    "demandMultiplier()": FunctionFragment;
    "emergencyPause(string)": FunctionFragment;
    "emergencyStopThreshold()": FunctionFragment;
    "emergencyWithdrawLDAO(uint256,address)": FunctionFragment;
    "executedTransactions(bytes32)": FunctionFragment;
    "getCircuitBreakerStatus()": FunctionFragment;
    "getCurrentDayPurchases()": FunctionFragment;
    "getDynamicPricingInfo()": FunctionFragment;
    "getPricingTier(uint256)": FunctionFragment;
    "getQuote(uint256)": FunctionFragment;
    "getTreasuryBalance()": FunctionFragment;
    "getUserDailyPurchases(address)": FunctionFragment;
    "getUserPurchaseHistory(address)": FunctionFragment;
    "kycApproved(address)": FunctionFragment;
    "kycRequired()": FunctionFragment;
    "lastPriceUpdate()": FunctionFragment;
    "lastPurchaseDay(address)": FunctionFragment;
    "lastResetDay()": FunctionFragment;
    "ldaoPriceInUSD()": FunctionFragment;
    "ldaoToken()": FunctionFragment;
    "maxPriceMultiplier()": FunctionFragment;
    "maxPurchaseAmount()": FunctionFragment;
    "minPurchaseAmount()": FunctionFragment;
    "multiSigWallet()": FunctionFragment;
    "nextTierId()": FunctionFragment;
    "owner()": FunctionFragment;
    "paused()": FunctionFragment;
    "priceUpdateInterval()": FunctionFragment;
    "pricingTiers(uint256)": FunctionFragment;
    "purchaseHistory(address)": FunctionFragment;
    "purchaseWithETH(uint256)": FunctionFragment;
    "purchaseWithUSDC(uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "salesActive()": FunctionFragment;
    "setKYCRequired(bool)": FunctionFragment;
    "setSalesActive(bool)": FunctionFragment;
    "totalRevenue()": FunctionFragment;
    "totalSold()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unpause()": FunctionFragment;
    "updateCircuitBreakerParams(uint256,uint256)": FunctionFragment;
    "updateDynamicPricingParams(uint256,uint256)": FunctionFragment;
    "updateKYCStatus(address,bool)": FunctionFragment;
    "updateLDAOPrice(uint256)": FunctionFragment;
    "updateMultiSigWallet(address)": FunctionFragment;
    "updatePricingTier(uint256,uint256,uint256,bool)": FunctionFragment;
    "updatePurchaseLimits(uint256,uint256)": FunctionFragment;
    "updateWhitelist(address,bool)": FunctionFragment;
    "usdcToken()": FunctionFragment;
    "whitelist(address)": FunctionFragment;
    "withdrawETH(uint256,address)": FunctionFragment;
    "withdrawToken(address,uint256,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MULTI_SIG_THRESHOLD"
      | "addPricingTier"
      | "basePriceInUSD"
      | "batchUpdateKYC"
      | "currentDayPurchases"
      | "dailyPurchaseLimit"
      | "dailyPurchases"
      | "demandMultiplier"
      | "emergencyPause"
      | "emergencyStopThreshold"
      | "emergencyWithdrawLDAO"
      | "executedTransactions"
      | "getCircuitBreakerStatus"
      | "getCurrentDayPurchases"
      | "getDynamicPricingInfo"
      | "getPricingTier"
      | "getQuote"
      | "getTreasuryBalance"
      | "getUserDailyPurchases"
      | "getUserPurchaseHistory"
      | "kycApproved"
      | "kycRequired"
      | "lastPriceUpdate"
      | "lastPurchaseDay"
      | "lastResetDay"
      | "ldaoPriceInUSD"
      | "ldaoToken"
      | "maxPriceMultiplier"
      | "maxPurchaseAmount"
      | "minPurchaseAmount"
      | "multiSigWallet"
      | "nextTierId"
      | "owner"
      | "paused"
      | "priceUpdateInterval"
      | "pricingTiers"
      | "purchaseHistory"
      | "purchaseWithETH"
      | "purchaseWithUSDC"
      | "renounceOwnership"
      | "salesActive"
      | "setKYCRequired"
      | "setSalesActive"
      | "totalRevenue"
      | "totalSold"
      | "transferOwnership"
      | "unpause"
      | "updateCircuitBreakerParams"
      | "updateDynamicPricingParams"
      | "updateKYCStatus"
      | "updateLDAOPrice"
      | "updateMultiSigWallet"
      | "updatePricingTier"
      | "updatePurchaseLimits"
      | "updateWhitelist"
      | "usdcToken"
      | "whitelist"
      | "withdrawETH"
      | "withdrawToken"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "MULTI_SIG_THRESHOLD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addPricingTier",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "basePriceInUSD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "batchUpdateKYC",
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "currentDayPurchases",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "dailyPurchaseLimit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "dailyPurchases",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "demandMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyPause",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyStopThreshold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyWithdrawLDAO",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "executedTransactions",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCircuitBreakerStatus",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentDayPurchases",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDynamicPricingInfo",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPricingTier",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getQuote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTreasuryBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getUserDailyPurchases",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserPurchaseHistory",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "kycApproved",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "kycRequired",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastPriceUpdate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastPurchaseDay",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "lastResetDay",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ldaoPriceInUSD",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "ldaoToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "maxPriceMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxPurchaseAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minPurchaseAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "multiSigWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextTierId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "priceUpdateInterval",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pricingTiers",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "purchaseHistory",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "purchaseWithETH",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "purchaseWithUSDC",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "salesActive",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setKYCRequired",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSalesActive",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalRevenue",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "totalSold", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateCircuitBreakerParams",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateDynamicPricingParams",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateKYCStatus",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateLDAOPrice",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMultiSigWallet",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePricingTier",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePurchaseLimits",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateWhitelist",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: "usdcToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "whitelist",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawETH",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "MULTI_SIG_THRESHOLD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addPricingTier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "basePriceInUSD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchUpdateKYC",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentDayPurchases",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dailyPurchaseLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dailyPurchases",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "demandMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyPause",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyStopThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyWithdrawLDAO",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executedTransactions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCircuitBreakerStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentDayPurchases",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDynamicPricingInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPricingTier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getQuote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTreasuryBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserDailyPurchases",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserPurchaseHistory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "kycApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "kycRequired",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastPriceUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastPurchaseDay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastResetDay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ldaoPriceInUSD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ldaoToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxPriceMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxPurchaseAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minPurchaseAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multiSigWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nextTierId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "priceUpdateInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pricingTiers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "purchaseHistory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "purchaseWithETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "purchaseWithUSDC",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "salesActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setKYCRequired",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSalesActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalRevenue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "totalSold", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateCircuitBreakerParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateDynamicPricingParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateKYCStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateLDAOPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMultiSigWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePricingTier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePurchaseLimits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "usdcToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "whitelist", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawToken",
    data: BytesLike
  ): Result;

  events: {
    "CircuitBreakerTriggered(uint256,uint256)": EventFragment;
    "DynamicPriceUpdated(uint256,uint256)": EventFragment;
    "EmergencyStop(string,uint256)": EventFragment;
    "FundsWithdrawn(address,uint256,address)": EventFragment;
    "KYCStatusUpdated(address,bool)": EventFragment;
    "LDAOPurchased(address,uint256,uint256,uint256,string)": EventFragment;
    "MultiSigWalletUpdated(address,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Paused(address)": EventFragment;
    "PriceUpdated(uint256,uint256)": EventFragment;
    "PricingTierAdded(uint256,uint256,uint256)": EventFragment;
    "SalesStatusUpdated(bool)": EventFragment;
    "Unpaused(address)": EventFragment;
    "WhitelistUpdated(address,bool)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CircuitBreakerTriggered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DynamicPriceUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EmergencyStop"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FundsWithdrawn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "KYCStatusUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LDAOPurchased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MultiSigWalletUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PriceUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PricingTierAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SalesStatusUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WhitelistUpdated"): EventFragment;
}

export interface CircuitBreakerTriggeredEventObject {
  dailyVolume: BigNumber;
  threshold: BigNumber;
}
export type CircuitBreakerTriggeredEvent = TypedEvent<
  [BigNumber, BigNumber],
  CircuitBreakerTriggeredEventObject
>;

export type CircuitBreakerTriggeredEventFilter =
  TypedEventFilter<CircuitBreakerTriggeredEvent>;

export interface DynamicPriceUpdatedEventObject {
  newPrice: BigNumber;
  demandMultiplier: BigNumber;
}
export type DynamicPriceUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  DynamicPriceUpdatedEventObject
>;

export type DynamicPriceUpdatedEventFilter =
  TypedEventFilter<DynamicPriceUpdatedEvent>;

export interface EmergencyStopEventObject {
  reason: string;
  timestamp: BigNumber;
}
export type EmergencyStopEvent = TypedEvent<
  [string, BigNumber],
  EmergencyStopEventObject
>;

export type EmergencyStopEventFilter = TypedEventFilter<EmergencyStopEvent>;

export interface FundsWithdrawnEventObject {
  token: string;
  amount: BigNumber;
  recipient: string;
}
export type FundsWithdrawnEvent = TypedEvent<
  [string, BigNumber, string],
  FundsWithdrawnEventObject
>;

export type FundsWithdrawnEventFilter = TypedEventFilter<FundsWithdrawnEvent>;

export interface KYCStatusUpdatedEventObject {
  user: string;
  approved: boolean;
}
export type KYCStatusUpdatedEvent = TypedEvent<
  [string, boolean],
  KYCStatusUpdatedEventObject
>;

export type KYCStatusUpdatedEventFilter =
  TypedEventFilter<KYCStatusUpdatedEvent>;

export interface LDAOPurchasedEventObject {
  buyer: string;
  ldaoAmount: BigNumber;
  usdAmount: BigNumber;
  ethAmount: BigNumber;
  paymentMethod: string;
}
export type LDAOPurchasedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, string],
  LDAOPurchasedEventObject
>;

export type LDAOPurchasedEventFilter = TypedEventFilter<LDAOPurchasedEvent>;

export interface MultiSigWalletUpdatedEventObject {
  oldWallet: string;
  newWallet: string;
}
export type MultiSigWalletUpdatedEvent = TypedEvent<
  [string, string],
  MultiSigWalletUpdatedEventObject
>;

export type MultiSigWalletUpdatedEventFilter =
  TypedEventFilter<MultiSigWalletUpdatedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface PriceUpdatedEventObject {
  oldPrice: BigNumber;
  newPrice: BigNumber;
}
export type PriceUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  PriceUpdatedEventObject
>;

export type PriceUpdatedEventFilter = TypedEventFilter<PriceUpdatedEvent>;

export interface PricingTierAddedEventObject {
  tierId: BigNumber;
  threshold: BigNumber;
  discountBps: BigNumber;
}
export type PricingTierAddedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  PricingTierAddedEventObject
>;

export type PricingTierAddedEventFilter =
  TypedEventFilter<PricingTierAddedEvent>;

export interface SalesStatusUpdatedEventObject {
  active: boolean;
}
export type SalesStatusUpdatedEvent = TypedEvent<
  [boolean],
  SalesStatusUpdatedEventObject
>;

export type SalesStatusUpdatedEventFilter =
  TypedEventFilter<SalesStatusUpdatedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface WhitelistUpdatedEventObject {
  user: string;
  whitelisted: boolean;
}
export type WhitelistUpdatedEvent = TypedEvent<
  [string, boolean],
  WhitelistUpdatedEventObject
>;

export type WhitelistUpdatedEventFilter =
  TypedEventFilter<WhitelistUpdatedEvent>;

export interface LDAOTreasury extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LDAOTreasuryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    MULTI_SIG_THRESHOLD(overrides?: CallOverrides): Promise<[BigNumber]>;

    addPricingTier(
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    basePriceInUSD(overrides?: CallOverrides): Promise<[BigNumber]>;

    batchUpdateKYC(
      users: PromiseOrValue<string>[],
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    currentDayPurchases(overrides?: CallOverrides): Promise<[BigNumber]>;

    dailyPurchaseLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    dailyPurchases(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    demandMultiplier(overrides?: CallOverrides): Promise<[BigNumber]>;

    emergencyPause(
      reason: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    emergencyStopThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    emergencyWithdrawLDAO(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executedTransactions(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getCircuitBreakerStatus(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean] & {
        dailyLimit: BigNumber;
        emergencyThreshold: BigNumber;
        currentVolume: BigNumber;
        nearEmergencyThreshold: boolean;
      }
    >;

    getCurrentDayPurchases(overrides?: CallOverrides): Promise<[BigNumber]>;

    getDynamicPricingInfo(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        currentPrice: BigNumber;
        basePrice: BigNumber;
        multiplier: BigNumber;
        nextUpdateTime: BigNumber;
      }
    >;

    getPricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        threshold: BigNumber;
        discountBps: BigNumber;
        active: boolean;
      }
    >;

    getQuote(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        usdAmount: BigNumber;
        ethAmount: BigNumber;
        usdcAmount: BigNumber;
        discount: BigNumber;
      }
    >;

    getTreasuryBalance(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        ldaoBalance: BigNumber;
        ethBalance: BigNumber;
        usdcBalance: BigNumber;
      }
    >;

    getUserDailyPurchases(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getUserPurchaseHistory(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    kycApproved(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    kycRequired(overrides?: CallOverrides): Promise<[boolean]>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastPurchaseDay(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    lastResetDay(overrides?: CallOverrides): Promise<[BigNumber]>;

    ldaoPriceInUSD(overrides?: CallOverrides): Promise<[BigNumber]>;

    ldaoToken(overrides?: CallOverrides): Promise<[string]>;

    maxPriceMultiplier(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxPurchaseAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    minPurchaseAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    multiSigWallet(overrides?: CallOverrides): Promise<[string]>;

    nextTierId(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    priceUpdateInterval(overrides?: CallOverrides): Promise<[BigNumber]>;

    pricingTiers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        threshold: BigNumber;
        discountBps: BigNumber;
        active: boolean;
      }
    >;

    purchaseHistory(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    purchaseWithETH(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    purchaseWithUSDC(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    salesActive(overrides?: CallOverrides): Promise<[boolean]>;

    setKYCRequired(
      required: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSalesActive(
      active: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    totalRevenue(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalSold(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateCircuitBreakerParams(
      _dailyLimit: PromiseOrValue<BigNumberish>,
      _emergencyThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateDynamicPricingParams(
      _maxPriceMultiplier: PromiseOrValue<BigNumberish>,
      _priceUpdateInterval: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateKYCStatus(
      user: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateLDAOPrice(
      newPriceInUSD: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateMultiSigWallet(
      newMultiSigWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updatePricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updatePurchaseLimits(
      minAmount: PromiseOrValue<BigNumberish>,
      maxAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateWhitelist(
      user: PromiseOrValue<string>,
      whitelisted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    usdcToken(overrides?: CallOverrides): Promise<[string]>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  MULTI_SIG_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

  addPricingTier(
    threshold: PromiseOrValue<BigNumberish>,
    discountBps: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  basePriceInUSD(overrides?: CallOverrides): Promise<BigNumber>;

  batchUpdateKYC(
    users: PromiseOrValue<string>[],
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  currentDayPurchases(overrides?: CallOverrides): Promise<BigNumber>;

  dailyPurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

  dailyPurchases(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  demandMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

  emergencyPause(
    reason: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  emergencyStopThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  emergencyWithdrawLDAO(
    amount: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executedTransactions(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getCircuitBreakerStatus(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, boolean] & {
      dailyLimit: BigNumber;
      emergencyThreshold: BigNumber;
      currentVolume: BigNumber;
      nearEmergencyThreshold: boolean;
    }
  >;

  getCurrentDayPurchases(overrides?: CallOverrides): Promise<BigNumber>;

  getDynamicPricingInfo(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      currentPrice: BigNumber;
      basePrice: BigNumber;
      multiplier: BigNumber;
      nextUpdateTime: BigNumber;
    }
  >;

  getPricingTier(
    tierId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & {
      threshold: BigNumber;
      discountBps: BigNumber;
      active: boolean;
    }
  >;

  getQuote(
    ldaoAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      usdAmount: BigNumber;
      ethAmount: BigNumber;
      usdcAmount: BigNumber;
      discount: BigNumber;
    }
  >;

  getTreasuryBalance(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      ldaoBalance: BigNumber;
      ethBalance: BigNumber;
      usdcBalance: BigNumber;
    }
  >;

  getUserDailyPurchases(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getUserPurchaseHistory(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  kycApproved(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  kycRequired(overrides?: CallOverrides): Promise<boolean>;

  lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  lastPurchaseDay(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  lastResetDay(overrides?: CallOverrides): Promise<BigNumber>;

  ldaoPriceInUSD(overrides?: CallOverrides): Promise<BigNumber>;

  ldaoToken(overrides?: CallOverrides): Promise<string>;

  maxPriceMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

  maxPurchaseAmount(overrides?: CallOverrides): Promise<BigNumber>;

  minPurchaseAmount(overrides?: CallOverrides): Promise<BigNumber>;

  multiSigWallet(overrides?: CallOverrides): Promise<string>;

  nextTierId(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  priceUpdateInterval(overrides?: CallOverrides): Promise<BigNumber>;

  pricingTiers(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & {
      threshold: BigNumber;
      discountBps: BigNumber;
      active: boolean;
    }
  >;

  purchaseHistory(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  purchaseWithETH(
    ldaoAmount: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  purchaseWithUSDC(
    ldaoAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  salesActive(overrides?: CallOverrides): Promise<boolean>;

  setKYCRequired(
    required: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSalesActive(
    active: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  totalRevenue(overrides?: CallOverrides): Promise<BigNumber>;

  totalSold(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unpause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateCircuitBreakerParams(
    _dailyLimit: PromiseOrValue<BigNumberish>,
    _emergencyThreshold: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateDynamicPricingParams(
    _maxPriceMultiplier: PromiseOrValue<BigNumberish>,
    _priceUpdateInterval: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateKYCStatus(
    user: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateLDAOPrice(
    newPriceInUSD: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateMultiSigWallet(
    newMultiSigWallet: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updatePricingTier(
    tierId: PromiseOrValue<BigNumberish>,
    threshold: PromiseOrValue<BigNumberish>,
    discountBps: PromiseOrValue<BigNumberish>,
    active: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updatePurchaseLimits(
    minAmount: PromiseOrValue<BigNumberish>,
    maxAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateWhitelist(
    user: PromiseOrValue<string>,
    whitelisted: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  usdcToken(overrides?: CallOverrides): Promise<string>;

  whitelist(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  withdrawETH(
    amount: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawToken(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    MULTI_SIG_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    addPricingTier(
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    basePriceInUSD(overrides?: CallOverrides): Promise<BigNumber>;

    batchUpdateKYC(
      users: PromiseOrValue<string>[],
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    currentDayPurchases(overrides?: CallOverrides): Promise<BigNumber>;

    dailyPurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

    dailyPurchases(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    demandMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyPause(
      reason: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    emergencyStopThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyWithdrawLDAO(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    executedTransactions(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getCircuitBreakerStatus(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean] & {
        dailyLimit: BigNumber;
        emergencyThreshold: BigNumber;
        currentVolume: BigNumber;
        nearEmergencyThreshold: boolean;
      }
    >;

    getCurrentDayPurchases(overrides?: CallOverrides): Promise<BigNumber>;

    getDynamicPricingInfo(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        currentPrice: BigNumber;
        basePrice: BigNumber;
        multiplier: BigNumber;
        nextUpdateTime: BigNumber;
      }
    >;

    getPricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        threshold: BigNumber;
        discountBps: BigNumber;
        active: boolean;
      }
    >;

    getQuote(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        usdAmount: BigNumber;
        ethAmount: BigNumber;
        usdcAmount: BigNumber;
        discount: BigNumber;
      }
    >;

    getTreasuryBalance(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        ldaoBalance: BigNumber;
        ethBalance: BigNumber;
        usdcBalance: BigNumber;
      }
    >;

    getUserDailyPurchases(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserPurchaseHistory(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    kycApproved(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    kycRequired(overrides?: CallOverrides): Promise<boolean>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lastPurchaseDay(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastResetDay(overrides?: CallOverrides): Promise<BigNumber>;

    ldaoPriceInUSD(overrides?: CallOverrides): Promise<BigNumber>;

    ldaoToken(overrides?: CallOverrides): Promise<string>;

    maxPriceMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    maxPurchaseAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minPurchaseAmount(overrides?: CallOverrides): Promise<BigNumber>;

    multiSigWallet(overrides?: CallOverrides): Promise<string>;

    nextTierId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    priceUpdateInterval(overrides?: CallOverrides): Promise<BigNumber>;

    pricingTiers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        threshold: BigNumber;
        discountBps: BigNumber;
        active: boolean;
      }
    >;

    purchaseHistory(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    purchaseWithETH(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    purchaseWithUSDC(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    salesActive(overrides?: CallOverrides): Promise<boolean>;

    setKYCRequired(
      required: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSalesActive(
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    totalRevenue(overrides?: CallOverrides): Promise<BigNumber>;

    totalSold(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unpause(overrides?: CallOverrides): Promise<void>;

    updateCircuitBreakerParams(
      _dailyLimit: PromiseOrValue<BigNumberish>,
      _emergencyThreshold: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateDynamicPricingParams(
      _maxPriceMultiplier: PromiseOrValue<BigNumberish>,
      _priceUpdateInterval: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateKYCStatus(
      user: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateLDAOPrice(
      newPriceInUSD: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateMultiSigWallet(
      newMultiSigWallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePurchaseLimits(
      minAmount: PromiseOrValue<BigNumberish>,
      maxAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateWhitelist(
      user: PromiseOrValue<string>,
      whitelisted: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    usdcToken(overrides?: CallOverrides): Promise<string>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "CircuitBreakerTriggered(uint256,uint256)"(
      dailyVolume?: null,
      threshold?: null
    ): CircuitBreakerTriggeredEventFilter;
    CircuitBreakerTriggered(
      dailyVolume?: null,
      threshold?: null
    ): CircuitBreakerTriggeredEventFilter;

    "DynamicPriceUpdated(uint256,uint256)"(
      newPrice?: null,
      demandMultiplier?: null
    ): DynamicPriceUpdatedEventFilter;
    DynamicPriceUpdated(
      newPrice?: null,
      demandMultiplier?: null
    ): DynamicPriceUpdatedEventFilter;

    "EmergencyStop(string,uint256)"(
      reason?: null,
      timestamp?: null
    ): EmergencyStopEventFilter;
    EmergencyStop(reason?: null, timestamp?: null): EmergencyStopEventFilter;

    "FundsWithdrawn(address,uint256,address)"(
      token?: PromiseOrValue<string> | null,
      amount?: null,
      recipient?: null
    ): FundsWithdrawnEventFilter;
    FundsWithdrawn(
      token?: PromiseOrValue<string> | null,
      amount?: null,
      recipient?: null
    ): FundsWithdrawnEventFilter;

    "KYCStatusUpdated(address,bool)"(
      user?: PromiseOrValue<string> | null,
      approved?: null
    ): KYCStatusUpdatedEventFilter;
    KYCStatusUpdated(
      user?: PromiseOrValue<string> | null,
      approved?: null
    ): KYCStatusUpdatedEventFilter;

    "LDAOPurchased(address,uint256,uint256,uint256,string)"(
      buyer?: PromiseOrValue<string> | null,
      ldaoAmount?: null,
      usdAmount?: null,
      ethAmount?: null,
      paymentMethod?: null
    ): LDAOPurchasedEventFilter;
    LDAOPurchased(
      buyer?: PromiseOrValue<string> | null,
      ldaoAmount?: null,
      usdAmount?: null,
      ethAmount?: null,
      paymentMethod?: null
    ): LDAOPurchasedEventFilter;

    "MultiSigWalletUpdated(address,address)"(
      oldWallet?: PromiseOrValue<string> | null,
      newWallet?: PromiseOrValue<string> | null
    ): MultiSigWalletUpdatedEventFilter;
    MultiSigWalletUpdated(
      oldWallet?: PromiseOrValue<string> | null,
      newWallet?: PromiseOrValue<string> | null
    ): MultiSigWalletUpdatedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "PriceUpdated(uint256,uint256)"(
      oldPrice?: null,
      newPrice?: null
    ): PriceUpdatedEventFilter;
    PriceUpdated(oldPrice?: null, newPrice?: null): PriceUpdatedEventFilter;

    "PricingTierAdded(uint256,uint256,uint256)"(
      tierId?: PromiseOrValue<BigNumberish> | null,
      threshold?: null,
      discountBps?: null
    ): PricingTierAddedEventFilter;
    PricingTierAdded(
      tierId?: PromiseOrValue<BigNumberish> | null,
      threshold?: null,
      discountBps?: null
    ): PricingTierAddedEventFilter;

    "SalesStatusUpdated(bool)"(active?: null): SalesStatusUpdatedEventFilter;
    SalesStatusUpdated(active?: null): SalesStatusUpdatedEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    "WhitelistUpdated(address,bool)"(
      user?: PromiseOrValue<string> | null,
      whitelisted?: null
    ): WhitelistUpdatedEventFilter;
    WhitelistUpdated(
      user?: PromiseOrValue<string> | null,
      whitelisted?: null
    ): WhitelistUpdatedEventFilter;
  };

  estimateGas: {
    MULTI_SIG_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    addPricingTier(
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    basePriceInUSD(overrides?: CallOverrides): Promise<BigNumber>;

    batchUpdateKYC(
      users: PromiseOrValue<string>[],
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    currentDayPurchases(overrides?: CallOverrides): Promise<BigNumber>;

    dailyPurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

    dailyPurchases(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    demandMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyPause(
      reason: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    emergencyStopThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyWithdrawLDAO(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executedTransactions(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCircuitBreakerStatus(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentDayPurchases(overrides?: CallOverrides): Promise<BigNumber>;

    getDynamicPricingInfo(overrides?: CallOverrides): Promise<BigNumber>;

    getPricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getQuote(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTreasuryBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getUserDailyPurchases(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserPurchaseHistory(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    kycApproved(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    kycRequired(overrides?: CallOverrides): Promise<BigNumber>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lastPurchaseDay(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastResetDay(overrides?: CallOverrides): Promise<BigNumber>;

    ldaoPriceInUSD(overrides?: CallOverrides): Promise<BigNumber>;

    ldaoToken(overrides?: CallOverrides): Promise<BigNumber>;

    maxPriceMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    maxPurchaseAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minPurchaseAmount(overrides?: CallOverrides): Promise<BigNumber>;

    multiSigWallet(overrides?: CallOverrides): Promise<BigNumber>;

    nextTierId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    priceUpdateInterval(overrides?: CallOverrides): Promise<BigNumber>;

    pricingTiers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    purchaseHistory(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    purchaseWithETH(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    purchaseWithUSDC(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    salesActive(overrides?: CallOverrides): Promise<BigNumber>;

    setKYCRequired(
      required: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSalesActive(
      active: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    totalRevenue(overrides?: CallOverrides): Promise<BigNumber>;

    totalSold(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateCircuitBreakerParams(
      _dailyLimit: PromiseOrValue<BigNumberish>,
      _emergencyThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateDynamicPricingParams(
      _maxPriceMultiplier: PromiseOrValue<BigNumberish>,
      _priceUpdateInterval: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateKYCStatus(
      user: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateLDAOPrice(
      newPriceInUSD: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateMultiSigWallet(
      newMultiSigWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updatePricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updatePurchaseLimits(
      minAmount: PromiseOrValue<BigNumberish>,
      maxAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateWhitelist(
      user: PromiseOrValue<string>,
      whitelisted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    usdcToken(overrides?: CallOverrides): Promise<BigNumber>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    MULTI_SIG_THRESHOLD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addPricingTier(
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    basePriceInUSD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    batchUpdateKYC(
      users: PromiseOrValue<string>[],
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    currentDayPurchases(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dailyPurchaseLimit(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dailyPurchases(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    demandMultiplier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyPause(
      reason: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    emergencyStopThreshold(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    emergencyWithdrawLDAO(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executedTransactions(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCircuitBreakerStatus(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrentDayPurchases(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDynamicPricingInfo(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getQuote(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTreasuryBalance(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserDailyPurchases(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserPurchaseHistory(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    kycApproved(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    kycRequired(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastPriceUpdate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastPurchaseDay(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastResetDay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ldaoPriceInUSD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ldaoToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxPriceMultiplier(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxPurchaseAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minPurchaseAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multiSigWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextTierId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceUpdateInterval(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pricingTiers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    purchaseHistory(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    purchaseWithETH(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    purchaseWithUSDC(
      ldaoAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    salesActive(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setKYCRequired(
      required: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSalesActive(
      active: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    totalRevenue(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateCircuitBreakerParams(
      _dailyLimit: PromiseOrValue<BigNumberish>,
      _emergencyThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateDynamicPricingParams(
      _maxPriceMultiplier: PromiseOrValue<BigNumberish>,
      _priceUpdateInterval: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateKYCStatus(
      user: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateLDAOPrice(
      newPriceInUSD: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateMultiSigWallet(
      newMultiSigWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updatePricingTier(
      tierId: PromiseOrValue<BigNumberish>,
      threshold: PromiseOrValue<BigNumberish>,
      discountBps: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updatePurchaseLimits(
      minAmount: PromiseOrValue<BigNumberish>,
      maxAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateWhitelist(
      user: PromiseOrValue<string>,
      whitelisted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    usdcToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
