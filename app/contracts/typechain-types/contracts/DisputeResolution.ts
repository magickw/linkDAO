/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export declare namespace DisputeResolution {
  export type DisputeStruct = {
    id: PromiseOrValue<BigNumberish>;
    escrowId: PromiseOrValue<BigNumberish>;
    initiator: PromiseOrValue<string>;
    respondent: PromiseOrValue<string>;
    disputeType: PromiseOrValue<BigNumberish>;
    description: PromiseOrValue<string>;
    status: PromiseOrValue<BigNumberish>;
    resolutionMethod: PromiseOrValue<BigNumberish>;
    createdAt: PromiseOrValue<BigNumberish>;
    evidenceDeadline: PromiseOrValue<BigNumberish>;
    votingDeadline: PromiseOrValue<BigNumberish>;
    resolvedAt: PromiseOrValue<BigNumberish>;
    verdict: PromiseOrValue<BigNumberish>;
    refundAmount: PromiseOrValue<BigNumberish>;
    resolver: PromiseOrValue<string>;
    escalatedToDAO: PromiseOrValue<boolean>;
  };

  export type DisputeStructOutput = [
    BigNumber,
    BigNumber,
    string,
    string,
    number,
    string,
    number,
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    BigNumber,
    string,
    boolean
  ] & {
    id: BigNumber;
    escrowId: BigNumber;
    initiator: string;
    respondent: string;
    disputeType: number;
    description: string;
    status: number;
    resolutionMethod: number;
    createdAt: BigNumber;
    evidenceDeadline: BigNumber;
    votingDeadline: BigNumber;
    resolvedAt: BigNumber;
    verdict: number;
    refundAmount: BigNumber;
    resolver: string;
    escalatedToDAO: boolean;
  };

  export type EvidenceStruct = {
    disputeId: PromiseOrValue<BigNumberish>;
    submitter: PromiseOrValue<string>;
    evidenceType: PromiseOrValue<string>;
    ipfsHash: PromiseOrValue<string>;
    description: PromiseOrValue<string>;
    timestamp: PromiseOrValue<BigNumberish>;
    verified: PromiseOrValue<boolean>;
  };

  export type EvidenceStructOutput = [
    BigNumber,
    string,
    string,
    string,
    string,
    BigNumber,
    boolean
  ] & {
    disputeId: BigNumber;
    submitter: string;
    evidenceType: string;
    ipfsHash: string;
    description: string;
    timestamp: BigNumber;
    verified: boolean;
  };

  export type CommunityVoteStruct = {
    voter: PromiseOrValue<string>;
    verdict: PromiseOrValue<BigNumberish>;
    votingPower: PromiseOrValue<BigNumberish>;
    reasoning: PromiseOrValue<string>;
    timestamp: PromiseOrValue<BigNumberish>;
  };

  export type CommunityVoteStructOutput = [
    string,
    number,
    BigNumber,
    string,
    BigNumber
  ] & {
    voter: string;
    verdict: number;
    votingPower: BigNumber;
    reasoning: string;
    timestamp: BigNumber;
  };
}

export interface DisputeResolutionInterface extends utils.Interface {
  functions: {
    "analytics()": FunctionFragment;
    "applyForArbitrator(string)": FunctionFragment;
    "approveArbitrator(address)": FunctionFragment;
    "approvedArbitrators(address)": FunctionFragment;
    "arbitratorApplications(address)": FunctionFragment;
    "arbitratorMinReputation()": FunctionFragment;
    "assignedArbitrators(uint256)": FunctionFragment;
    "castCommunityVote(uint256,uint8,string)": FunctionFragment;
    "communityVotingPeriod()": FunctionFragment;
    "createDispute(uint256,address,uint8,string)": FunctionFragment;
    "daoEscalationThreshold()": FunctionFragment;
    "disputeEvidence(uint256,uint256)": FunctionFragment;
    "disputeVotes(uint256,uint256)": FunctionFragment;
    "disputes(uint256)": FunctionFragment;
    "evidenceSubmissionPeriod()": FunctionFragment;
    "getDispute(uint256)": FunctionFragment;
    "getDisputeAnalytics()": FunctionFragment;
    "getDisputeEvidence(uint256)": FunctionFragment;
    "getDisputeVotes(uint256)": FunctionFragment;
    "governance()": FunctionFragment;
    "hasVoted(uint256,address)": FunctionFragment;
    "minimumVotingPower()": FunctionFragment;
    "nextDisputeId()": FunctionFragment;
    "owner()": FunctionFragment;
    "proceedToArbitration(uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "reputationSystem()": FunctionFragment;
    "resolveAsArbitrator(uint256,uint8,uint256,string)": FunctionFragment;
    "submitEvidence(uint256,string,string,string)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "analytics"
      | "applyForArbitrator"
      | "approveArbitrator"
      | "approvedArbitrators"
      | "arbitratorApplications"
      | "arbitratorMinReputation"
      | "assignedArbitrators"
      | "castCommunityVote"
      | "communityVotingPeriod"
      | "createDispute"
      | "daoEscalationThreshold"
      | "disputeEvidence"
      | "disputeVotes"
      | "disputes"
      | "evidenceSubmissionPeriod"
      | "getDispute"
      | "getDisputeAnalytics"
      | "getDisputeEvidence"
      | "getDisputeVotes"
      | "governance"
      | "hasVoted"
      | "minimumVotingPower"
      | "nextDisputeId"
      | "owner"
      | "proceedToArbitration"
      | "renounceOwnership"
      | "reputationSystem"
      | "resolveAsArbitrator"
      | "submitEvidence"
      | "transferOwnership"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "analytics", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "applyForArbitrator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "approveArbitrator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "approvedArbitrators",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "arbitratorApplications",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "arbitratorMinReputation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "assignedArbitrators",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "castCommunityVote",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "communityVotingPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "createDispute",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "daoEscalationThreshold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "disputeEvidence",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "disputeVotes",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "disputes",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "evidenceSubmissionPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDispute",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getDisputeAnalytics",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDisputeEvidence",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getDisputeVotes",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "governance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hasVoted",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "minimumVotingPower",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextDisputeId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proceedToArbitration",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reputationSystem",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resolveAsArbitrator",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitEvidence",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(functionFragment: "analytics", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "applyForArbitrator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveArbitrator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approvedArbitrators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "arbitratorApplications",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "arbitratorMinReputation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assignedArbitrators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "castCommunityVote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "communityVotingPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createDispute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "daoEscalationThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeEvidence",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeVotes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "disputes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "evidenceSubmissionPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDispute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDisputeAnalytics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDisputeEvidence",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDisputeVotes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hasVoted", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "minimumVotingPower",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextDisputeId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proceedToArbitration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reputationSystem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resolveAsArbitrator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitEvidence",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;

  events: {
    "ArbitratorApplicationSubmitted(address,uint256)": EventFragment;
    "ArbitratorApproved(address)": EventFragment;
    "ArbitratorAssigned(uint256,address)": EventFragment;
    "CommunityVoteCast(uint256,address,uint8,uint256)": EventFragment;
    "DisputeCreated(uint256,uint256,address,address,uint8)": EventFragment;
    "DisputeEscalated(uint256,uint8,uint8)": EventFragment;
    "DisputeResolved(uint256,uint8,uint256,address)": EventFragment;
    "EvidenceSubmitted(uint256,address,string,string)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: "ArbitratorApplicationSubmitted"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ArbitratorApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ArbitratorAssigned"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CommunityVoteCast"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DisputeCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DisputeEscalated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DisputeResolved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EvidenceSubmitted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface ArbitratorApplicationSubmittedEventObject {
  applicant: string;
  reputationScore: BigNumber;
}
export type ArbitratorApplicationSubmittedEvent = TypedEvent<
  [string, BigNumber],
  ArbitratorApplicationSubmittedEventObject
>;

export type ArbitratorApplicationSubmittedEventFilter =
  TypedEventFilter<ArbitratorApplicationSubmittedEvent>;

export interface ArbitratorApprovedEventObject {
  arbitrator: string;
}
export type ArbitratorApprovedEvent = TypedEvent<
  [string],
  ArbitratorApprovedEventObject
>;

export type ArbitratorApprovedEventFilter =
  TypedEventFilter<ArbitratorApprovedEvent>;

export interface ArbitratorAssignedEventObject {
  disputeId: BigNumber;
  arbitrator: string;
}
export type ArbitratorAssignedEvent = TypedEvent<
  [BigNumber, string],
  ArbitratorAssignedEventObject
>;

export type ArbitratorAssignedEventFilter =
  TypedEventFilter<ArbitratorAssignedEvent>;

export interface CommunityVoteCastEventObject {
  disputeId: BigNumber;
  voter: string;
  verdict: number;
  votingPower: BigNumber;
}
export type CommunityVoteCastEvent = TypedEvent<
  [BigNumber, string, number, BigNumber],
  CommunityVoteCastEventObject
>;

export type CommunityVoteCastEventFilter =
  TypedEventFilter<CommunityVoteCastEvent>;

export interface DisputeCreatedEventObject {
  disputeId: BigNumber;
  escrowId: BigNumber;
  initiator: string;
  respondent: string;
  disputeType: number;
}
export type DisputeCreatedEvent = TypedEvent<
  [BigNumber, BigNumber, string, string, number],
  DisputeCreatedEventObject
>;

export type DisputeCreatedEventFilter = TypedEventFilter<DisputeCreatedEvent>;

export interface DisputeEscalatedEventObject {
  disputeId: BigNumber;
  fromMethod: number;
  toMethod: number;
}
export type DisputeEscalatedEvent = TypedEvent<
  [BigNumber, number, number],
  DisputeEscalatedEventObject
>;

export type DisputeEscalatedEventFilter =
  TypedEventFilter<DisputeEscalatedEvent>;

export interface DisputeResolvedEventObject {
  disputeId: BigNumber;
  verdict: number;
  refundAmount: BigNumber;
  resolver: string;
}
export type DisputeResolvedEvent = TypedEvent<
  [BigNumber, number, BigNumber, string],
  DisputeResolvedEventObject
>;

export type DisputeResolvedEventFilter = TypedEventFilter<DisputeResolvedEvent>;

export interface EvidenceSubmittedEventObject {
  disputeId: BigNumber;
  submitter: string;
  evidenceType: string;
  ipfsHash: string;
}
export type EvidenceSubmittedEvent = TypedEvent<
  [BigNumber, string, string, string],
  EvidenceSubmittedEventObject
>;

export type EvidenceSubmittedEventFilter =
  TypedEventFilter<EvidenceSubmittedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface DisputeResolution extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: DisputeResolutionInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    analytics(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalDisputes: BigNumber;
        resolvedDisputes: BigNumber;
        averageResolutionTime: BigNumber;
      }
    >;

    applyForArbitrator(
      qualifications: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approveArbitrator(
      applicant: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approvedArbitrators(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    arbitratorApplications(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, BigNumber, BigNumber, boolean, BigNumber] & {
        applicant: string;
        qualifications: string;
        reputationScore: BigNumber;
        casesHandled: BigNumber;
        successRate: BigNumber;
        approved: boolean;
        appliedAt: BigNumber;
      }
    >;

    arbitratorMinReputation(overrides?: CallOverrides): Promise<[BigNumber]>;

    assignedArbitrators(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    castCommunityVote(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    communityVotingPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    createDispute(
      escrowId: PromiseOrValue<BigNumberish>,
      respondent: PromiseOrValue<string>,
      disputeType: PromiseOrValue<BigNumberish>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    daoEscalationThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    disputeEvidence(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, string, string, string, BigNumber, boolean] & {
        disputeId: BigNumber;
        submitter: string;
        evidenceType: string;
        ipfsHash: string;
        description: string;
        timestamp: BigNumber;
        verified: boolean;
      }
    >;

    disputeVotes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber, string, BigNumber] & {
        voter: string;
        verdict: number;
        votingPower: BigNumber;
        reasoning: string;
        timestamp: BigNumber;
      }
    >;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        string,
        string,
        number,
        string,
        number,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber,
        string,
        boolean
      ] & {
        id: BigNumber;
        escrowId: BigNumber;
        initiator: string;
        respondent: string;
        disputeType: number;
        description: string;
        status: number;
        resolutionMethod: number;
        createdAt: BigNumber;
        evidenceDeadline: BigNumber;
        votingDeadline: BigNumber;
        resolvedAt: BigNumber;
        verdict: number;
        refundAmount: BigNumber;
        resolver: string;
        escalatedToDAO: boolean;
      }
    >;

    evidenceSubmissionPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    getDispute(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[DisputeResolution.DisputeStructOutput]>;

    getDisputeAnalytics(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalDisputes: BigNumber;
        resolvedDisputes: BigNumber;
        averageResolutionTime: BigNumber;
      }
    >;

    getDisputeEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[DisputeResolution.EvidenceStructOutput[]]>;

    getDisputeVotes(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[DisputeResolution.CommunityVoteStructOutput[]]>;

    governance(overrides?: CallOverrides): Promise<[string]>;

    hasVoted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    minimumVotingPower(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextDisputeId(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    proceedToArbitration(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    reputationSystem(overrides?: CallOverrides): Promise<[string]>;

    resolveAsArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      refundAmount: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      evidenceType: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  analytics(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      totalDisputes: BigNumber;
      resolvedDisputes: BigNumber;
      averageResolutionTime: BigNumber;
    }
  >;

  applyForArbitrator(
    qualifications: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approveArbitrator(
    applicant: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approvedArbitrators(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  arbitratorApplications(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [string, string, BigNumber, BigNumber, BigNumber, boolean, BigNumber] & {
      applicant: string;
      qualifications: string;
      reputationScore: BigNumber;
      casesHandled: BigNumber;
      successRate: BigNumber;
      approved: boolean;
      appliedAt: BigNumber;
    }
  >;

  arbitratorMinReputation(overrides?: CallOverrides): Promise<BigNumber>;

  assignedArbitrators(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  castCommunityVote(
    disputeId: PromiseOrValue<BigNumberish>,
    verdict: PromiseOrValue<BigNumberish>,
    reasoning: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  communityVotingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  createDispute(
    escrowId: PromiseOrValue<BigNumberish>,
    respondent: PromiseOrValue<string>,
    disputeType: PromiseOrValue<BigNumberish>,
    description: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  daoEscalationThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  disputeEvidence(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, string, string, string, BigNumber, boolean] & {
      disputeId: BigNumber;
      submitter: string;
      evidenceType: string;
      ipfsHash: string;
      description: string;
      timestamp: BigNumber;
      verified: boolean;
    }
  >;

  disputeVotes(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, number, BigNumber, string, BigNumber] & {
      voter: string;
      verdict: number;
      votingPower: BigNumber;
      reasoning: string;
      timestamp: BigNumber;
    }
  >;

  disputes(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      string,
      string,
      number,
      string,
      number,
      number,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      BigNumber,
      string,
      boolean
    ] & {
      id: BigNumber;
      escrowId: BigNumber;
      initiator: string;
      respondent: string;
      disputeType: number;
      description: string;
      status: number;
      resolutionMethod: number;
      createdAt: BigNumber;
      evidenceDeadline: BigNumber;
      votingDeadline: BigNumber;
      resolvedAt: BigNumber;
      verdict: number;
      refundAmount: BigNumber;
      resolver: string;
      escalatedToDAO: boolean;
    }
  >;

  evidenceSubmissionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  getDispute(
    disputeId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<DisputeResolution.DisputeStructOutput>;

  getDisputeAnalytics(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      totalDisputes: BigNumber;
      resolvedDisputes: BigNumber;
      averageResolutionTime: BigNumber;
    }
  >;

  getDisputeEvidence(
    disputeId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<DisputeResolution.EvidenceStructOutput[]>;

  getDisputeVotes(
    disputeId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<DisputeResolution.CommunityVoteStructOutput[]>;

  governance(overrides?: CallOverrides): Promise<string>;

  hasVoted(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  minimumVotingPower(overrides?: CallOverrides): Promise<BigNumber>;

  nextDisputeId(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  proceedToArbitration(
    disputeId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  reputationSystem(overrides?: CallOverrides): Promise<string>;

  resolveAsArbitrator(
    disputeId: PromiseOrValue<BigNumberish>,
    verdict: PromiseOrValue<BigNumberish>,
    refundAmount: PromiseOrValue<BigNumberish>,
    reasoning: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitEvidence(
    disputeId: PromiseOrValue<BigNumberish>,
    evidenceType: PromiseOrValue<string>,
    ipfsHash: PromiseOrValue<string>,
    description: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    analytics(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalDisputes: BigNumber;
        resolvedDisputes: BigNumber;
        averageResolutionTime: BigNumber;
      }
    >;

    applyForArbitrator(
      qualifications: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    approveArbitrator(
      applicant: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    approvedArbitrators(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    arbitratorApplications(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, BigNumber, BigNumber, boolean, BigNumber] & {
        applicant: string;
        qualifications: string;
        reputationScore: BigNumber;
        casesHandled: BigNumber;
        successRate: BigNumber;
        approved: boolean;
        appliedAt: BigNumber;
      }
    >;

    arbitratorMinReputation(overrides?: CallOverrides): Promise<BigNumber>;

    assignedArbitrators(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    castCommunityVote(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    communityVotingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    createDispute(
      escrowId: PromiseOrValue<BigNumberish>,
      respondent: PromiseOrValue<string>,
      disputeType: PromiseOrValue<BigNumberish>,
      description: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    daoEscalationThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    disputeEvidence(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, string, string, string, BigNumber, boolean] & {
        disputeId: BigNumber;
        submitter: string;
        evidenceType: string;
        ipfsHash: string;
        description: string;
        timestamp: BigNumber;
        verified: boolean;
      }
    >;

    disputeVotes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber, string, BigNumber] & {
        voter: string;
        verdict: number;
        votingPower: BigNumber;
        reasoning: string;
        timestamp: BigNumber;
      }
    >;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        string,
        string,
        number,
        string,
        number,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber,
        string,
        boolean
      ] & {
        id: BigNumber;
        escrowId: BigNumber;
        initiator: string;
        respondent: string;
        disputeType: number;
        description: string;
        status: number;
        resolutionMethod: number;
        createdAt: BigNumber;
        evidenceDeadline: BigNumber;
        votingDeadline: BigNumber;
        resolvedAt: BigNumber;
        verdict: number;
        refundAmount: BigNumber;
        resolver: string;
        escalatedToDAO: boolean;
      }
    >;

    evidenceSubmissionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    getDispute(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<DisputeResolution.DisputeStructOutput>;

    getDisputeAnalytics(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalDisputes: BigNumber;
        resolvedDisputes: BigNumber;
        averageResolutionTime: BigNumber;
      }
    >;

    getDisputeEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<DisputeResolution.EvidenceStructOutput[]>;

    getDisputeVotes(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<DisputeResolution.CommunityVoteStructOutput[]>;

    governance(overrides?: CallOverrides): Promise<string>;

    hasVoted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    minimumVotingPower(overrides?: CallOverrides): Promise<BigNumber>;

    nextDisputeId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    proceedToArbitration(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    reputationSystem(overrides?: CallOverrides): Promise<string>;

    resolveAsArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      refundAmount: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      evidenceType: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ArbitratorApplicationSubmitted(address,uint256)"(
      applicant?: PromiseOrValue<string> | null,
      reputationScore?: null
    ): ArbitratorApplicationSubmittedEventFilter;
    ArbitratorApplicationSubmitted(
      applicant?: PromiseOrValue<string> | null,
      reputationScore?: null
    ): ArbitratorApplicationSubmittedEventFilter;

    "ArbitratorApproved(address)"(
      arbitrator?: PromiseOrValue<string> | null
    ): ArbitratorApprovedEventFilter;
    ArbitratorApproved(
      arbitrator?: PromiseOrValue<string> | null
    ): ArbitratorApprovedEventFilter;

    "ArbitratorAssigned(uint256,address)"(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      arbitrator?: PromiseOrValue<string> | null
    ): ArbitratorAssignedEventFilter;
    ArbitratorAssigned(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      arbitrator?: PromiseOrValue<string> | null
    ): ArbitratorAssignedEventFilter;

    "CommunityVoteCast(uint256,address,uint8,uint256)"(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      voter?: PromiseOrValue<string> | null,
      verdict?: null,
      votingPower?: null
    ): CommunityVoteCastEventFilter;
    CommunityVoteCast(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      voter?: PromiseOrValue<string> | null,
      verdict?: null,
      votingPower?: null
    ): CommunityVoteCastEventFilter;

    "DisputeCreated(uint256,uint256,address,address,uint8)"(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      escrowId?: PromiseOrValue<BigNumberish> | null,
      initiator?: PromiseOrValue<string> | null,
      respondent?: null,
      disputeType?: null
    ): DisputeCreatedEventFilter;
    DisputeCreated(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      escrowId?: PromiseOrValue<BigNumberish> | null,
      initiator?: PromiseOrValue<string> | null,
      respondent?: null,
      disputeType?: null
    ): DisputeCreatedEventFilter;

    "DisputeEscalated(uint256,uint8,uint8)"(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      fromMethod?: null,
      toMethod?: null
    ): DisputeEscalatedEventFilter;
    DisputeEscalated(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      fromMethod?: null,
      toMethod?: null
    ): DisputeEscalatedEventFilter;

    "DisputeResolved(uint256,uint8,uint256,address)"(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      verdict?: null,
      refundAmount?: null,
      resolver?: null
    ): DisputeResolvedEventFilter;
    DisputeResolved(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      verdict?: null,
      refundAmount?: null,
      resolver?: null
    ): DisputeResolvedEventFilter;

    "EvidenceSubmitted(uint256,address,string,string)"(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      submitter?: PromiseOrValue<string> | null,
      evidenceType?: null,
      ipfsHash?: null
    ): EvidenceSubmittedEventFilter;
    EvidenceSubmitted(
      disputeId?: PromiseOrValue<BigNumberish> | null,
      submitter?: PromiseOrValue<string> | null,
      evidenceType?: null,
      ipfsHash?: null
    ): EvidenceSubmittedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    analytics(overrides?: CallOverrides): Promise<BigNumber>;

    applyForArbitrator(
      qualifications: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approveArbitrator(
      applicant: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approvedArbitrators(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    arbitratorApplications(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    arbitratorMinReputation(overrides?: CallOverrides): Promise<BigNumber>;

    assignedArbitrators(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    castCommunityVote(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    communityVotingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    createDispute(
      escrowId: PromiseOrValue<BigNumberish>,
      respondent: PromiseOrValue<string>,
      disputeType: PromiseOrValue<BigNumberish>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    daoEscalationThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    disputeEvidence(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    disputeVotes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    evidenceSubmissionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    getDispute(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDisputeAnalytics(overrides?: CallOverrides): Promise<BigNumber>;

    getDisputeEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDisputeVotes(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    hasVoted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumVotingPower(overrides?: CallOverrides): Promise<BigNumber>;

    nextDisputeId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    proceedToArbitration(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    reputationSystem(overrides?: CallOverrides): Promise<BigNumber>;

    resolveAsArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      refundAmount: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      evidenceType: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    analytics(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    applyForArbitrator(
      qualifications: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approveArbitrator(
      applicant: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approvedArbitrators(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    arbitratorApplications(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    arbitratorMinReputation(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assignedArbitrators(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    castCommunityVote(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    communityVotingPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createDispute(
      escrowId: PromiseOrValue<BigNumberish>,
      respondent: PromiseOrValue<string>,
      disputeType: PromiseOrValue<BigNumberish>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    daoEscalationThreshold(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    disputeEvidence(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    disputeVotes(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    evidenceSubmissionPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDispute(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDisputeAnalytics(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDisputeEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDisputeVotes(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    hasVoted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minimumVotingPower(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nextDisputeId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proceedToArbitration(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    reputationSystem(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolveAsArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      verdict: PromiseOrValue<BigNumberish>,
      refundAmount: PromiseOrValue<BigNumberish>,
      reasoning: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitEvidence(
      disputeId: PromiseOrValue<BigNumberish>,
      evidenceType: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
